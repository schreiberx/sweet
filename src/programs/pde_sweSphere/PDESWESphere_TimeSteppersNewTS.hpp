/*
 * Author: Martin SCHREIBER <schreiberx@gmail.com>
 */

#ifndef SRC_PROGRAMS_SWE_SPHERE_TIMESTEPPERS_HPP_
#define SRC_PROGRAMS_SWE_SPHERE_TIMESTEPPERS_HPP_

#include <sweet/core/ErrorBase.hpp>

#include <sweet/core/shacks/ShackProgArgDictionary.hpp>
#include <sweet/core/sphere/SphereData_Spectral.hpp>
#include <sweet/core/ErrorBase.hpp>

#include <sweet/timeTree/DESolver_TimeTreeNode_Base.hpp>
#include <sweet/timeTree/DESolver_TimeStepperRegistryAll.hpp>
#include <sweet/timeTree/DESolver_TimeTreeNode_Registry.hpp>

#include <sweet/timeTree/DESolver_TimeStepping_StringParser.hpp>
#include <sweet/timeTree/DESolver_TimeStepping_Tree.hpp>
#include <sweet/timeTree/DESolver_TimeStepping_Assemblation.hpp>

#include "timeTree/PDESWESphere_lg.hpp"
#include "timeTree/PDESWESphere_lc.hpp"
#include "timeTree/PDESWESphere_DataContainer.hpp"
#include "timeTree/PDESWESphere_DESolver_Config.hpp"

/**
 * SWE Plane time steppers
 */
class PDESWESphere_TimeSteppersNewTS
{
public:
	sweet::ErrorBase error;

	std::shared_ptr<sweet::DESolver_TimeTreeNode_Base> timeIntegrator;

	// the time stepping tree generated by the string
	sweet::DESolver_TimeStepping_Tree tsTree;

	// A registry of all PDE terms
	sweet::DESolver_TimeTreeNode_Registry pdeTerm_registry;

	// A registry of all time steppers
	sweet::DESolver_TimeTreeNode_Registry timeStepper_registry;

	// Config file for DE solver
	PDESWESphere_DESolver_Config deSolver_Config;
public:
	void setup_1_registerAllTimesteppers()
	{

		/*
		 * Registration of all possible PDE terms
		 */
		pdeTerm_registry.registerTimeTreeNode<PDESWESphere_lg>();
		pdeTerm_registry.registerTimeTreeNode<PDESWESphere_lc>();

		/*
		 * Register time steppers
		 */
		sweet::DESolver_TimeStepperRegistryAll registryAll;
		registryAll.registerAll(timeStepper_registry);
	}


public:
	PDESWESphere_TimeSteppersNewTS()
	{
	}

	void printImplementedTimesteppingMethods(
		std::ostream &o_ostream = std::cout,
		const std::string &i_prefix = ""
	);

	bool setup_2_timestepper(
			const std::string &i_timestepping_method,
			sweet::ShackDictionary *i_shackDict,
			sweet::SphereOperators *io_ops,
			const PDESWESphere_DataContainer &i_U
	)
	{
		/*
		 * Setup time stepping string parser and parse it
		 */
		sweet::DESolver_TimeSteppingStringParser tsStringParser;
		tsStringParser.genTimeSteppingTree(
				i_timestepping_method,
				tsTree
			);
		ERROR_CHECK_WITH_FORWARD_AND_COND_RETURN_BOOLEAN(tsStringParser);
		tsTree.print();

		/*
		 * Ready to assemble time stepper
		 */
		sweet::DESolver_TimeStepping_Assemblation tssa;
		tssa.setup(pdeTerm_registry, timeStepper_registry);
		tssa.assembleTimeStepperByTree(
			tsTree,
			timeIntegrator
		);
		ERROR_CHECK_WITH_FORWARD_AND_COND_RETURN_BOOLEAN(tssa);

		timeIntegrator->shackRegistration(i_shackDict);
		ERROR_CHECK_WITH_FORWARD_AND_COND_RETURN_BOOLEAN(*timeIntegrator);

		deSolver_Config.myDataContainer = &i_U;
		deSolver_Config.ops = io_ops;
		timeIntegrator->setupConfig(deSolver_Config);
		ERROR_CHECK_WITH_FORWARD_AND_COND_RETURN_BOOLEAN(*timeIntegrator);

		/*
		 * Set time step size
		 */
		timeIntegrator->setTimeStepSize(0.1);

		return true;
	}

	void clear()
	{
	}


	~PDESWESphere_TimeSteppersNewTS()
	{
	}
};




#endif
