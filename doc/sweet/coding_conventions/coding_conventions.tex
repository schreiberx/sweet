\documentclass[10pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage{listings}

\author{Martin Schreiber}
\title{Coding guidelines for SWEET}
\date{Last updated: \today}
	
	
	
\begin{document}

\maketitle

\section{Purpose}
Different developers working together have usually different coding conventions.
Therefore an agreement to coding conventions has to be achieved when working together on one project for several reasons.
One of the main reasons is to keep the code clean and thus to maintain a better code structure.

\section{Coding conventions for Python}

The entire workflow to compile and execute code written in SWEET as well as the postprocessing is mainly written in Python.
We use Python 3 without any exceptions!
Generally, please try to follow PEP8 guidelines which can be found at \url{https://www.python.org/dev/peps/pep-0008/} with the following exceptions:

\begin{itemize}
	\item Use tab indentation with tabs configures to take 4 spaces\\
	In VIM, this can be configured with\\
	\texttt{autocmd Filetype python setlocal tabstop=4 shiftwidth=4}
	\item Use Unix encoded python source code files
\end{itemize}




\section{Coding conventions for C++}

\subsection{Eclipse configuration}
Eclipse supports features for automatic formattation of code via [Source] $\rightarrow$ [Format].
The style which is used by SWEET is programmed is closely related to "GNU/Allman" and a profile file ``SWEET\_eclipse\_formattation.xml'' is available in the current folder.
This can be loaded via [Project] $\rightarrow$ [Properties] $\rightarrow$ [C/C++ General] $\rightarrow$ [Formatter].
Make sure to tick the box ``Enable project specific settings'' and [Import] the SWEET profile.

\subsection{Identation}
Blocks and scopes have to be indented by using a single TAB for each identation.

\subsection{Naming conventions}

\subsubsection{Types}

Types are distinguished whether they are used as a
\begin{itemize}
	\item class,
	\item class with templates
	\item typedef followed by a specialized class
	\item classes without templates
	\item atomic variables (int, char, float, ...)
\end{itemize}

%When classes are defined, they are always prefixed with a  capital letter 'C' denoting that they are a class.
%Also classes with template parameters are prefixed with the 'C'.

%As soon as a class (with or without template parameters) is given as a template parameter or redefined via a typedef, the 'C' is replaced by a 'T' to account for a fixed type without necessity of template parameters. 

\subsubsection{Variable naming}

\begin{itemize}
	\item For atomic types (int, char, float, etc.), all variables have to be written using underscores and small letters.

	\item For class types, the class variables have to be written without underscores
\end{itemize}

\subsubsection{Parameters for methods}

parameters of methods are prefixed by i\_, o\_ or io\_.
\begin{itemize}
      \item i\_ means that this parameter is accessed read/only (const).
      \item o\_ is used to declare this parameter as being an output reference to write some output values.
      \item io\_ is used to declare an input/output pointer or reference which is read and written.
\end{itemize}
Output parameters always have to be of type pointer.
No references should ever be used for output parameters!
Return values handed back to the calling method are still allowed and have so far no convention.


\begin{lstlisting}
/**
 * some comment
 *
 * \return description of return value 
 */
char foo(
    const int i_bar_var,     
                  ///< this is a totally useless variable
    const SomeClass &i_someClass,    
                  ///< input via referenced parameter
    SomeClass *o_someOutputClass
                  ///< output via pointer parameter
) {
    while (true) {
        ...
    }
    return 42;
}
\end{lstlisting}

\subsection{Template parameters}
ALL template parameters have to be prefixed with a "t\_" to differ between template types and other types.


\subsection{Comments}
Comments are one of the most important thing in writing code.
Therefore as much comments as are necessary or being requested by other developers have to be written.

Equations in comments can be e.g. written with  {\textbackslash}f\$ f(x):=1+2x {\textbackslash}f\$.
See https://www.stack.nl/~dimitri/doxygen/manual/formulas.html for examples.



\begin{lstlisting}
/**
 * comments preceeding functions should
 * follow the doxygen (www.doxygen.org)
 * code-style
 *
 * \return description of return value 
 */
void foo(
    const int i_bar_var, ///< this is totally useless
    void *io_foo_var     ///< this variable is not
                         ///< able to drink beer
) {
    while (true) {
        ...
    }
}

constructor(
    int i_val,	///< index
) :
  some_variable(i_val)
{
	...
}
\end{lstlisting}

\end{document}
